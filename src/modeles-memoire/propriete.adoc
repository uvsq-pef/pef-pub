:imagesdir: figs/
:stem:

= Mod√®le m√©moire Rust: propri√©t√© et emprunts 

== Objectifs
L'innovation majeure de Rust est son mod√®le m√©moire qui combine:

- des v√©rifications statiques qui permettent de d√©tecter les probl√®mes m√©moire
- des abstractions √† co√ªt nul qui permettent de g√©n√©rer un code efficace

Nous allons √©tudier les notions que Rust introduit pour garantir que les programmes sont corrects en m√©moire, en particulier les notions de _Propri√©t√©_ (Ownership) et _Emprunt_ (Borrow).

== Mutabilit√© 
- Par d√©faut les variables sont immutables

[source, rust]
----
    let a = 1;
    let mut b = 1;
    a = 2; // erreur: Cannot assign twice to immutable variable a
    b = 2; // ok
----

== Les variables locales sont allou√©es sur la pile
[source, rust]
----
fn main() {
    let a : u32 = 1;
    let b : f32 = 3.1415;
    let c : [u32; 3] = [1, 2, 3];
    let d = [0; 1 << 30]; // tableau avec 2^30 z√©ros => d√©bordement de pile 
}
----

- Les types primitifs de Rust sont allou√©s sur la pile.

== Allocation sur le tas
- Rust permet aussi d'allouer dynamiquement des objets sur le tas.
- Par exemple, les vecteurs de type https://doc.rust-lang.org/std/vec/struct.Vec.html[`Vec<T>`] sont allou√©s sur le tas.

[source, rust]
----
let v : Vec<u32> = vec![1,2,3]; // <1>
----
<1> Ici `v` est une variable locale (sur la pile) qui contient un pointeur vers une adresse du tas o√π l'objet de type `Vec<u32>` est allou√©.

== Propri√©taire
Pour toute donn√©e, rust d√©finit une variable https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html[_propri√©taire_].

[IMPORTANT]
====
* Chaque valeur a un propri√©taire.
* √Ä tout moment il ne peut y avoir qu'un et un seul propri√©taire. 
* Quand le propri√©taire devient _hors-port√©e_, la valeur est supprim√©e.
====

[source, rust]
----
fn test() {
    let a = 1.0; //<1>
    let v = vec![1,2,3]; //<2>
    // fin du bloc <3>
}
----
<1> `a` est propri√©taire du scalaire
<2> `v` est propri√©taire du vecteur
<3> En fin de bloc `a` et `v` sont _hors-port√©e_. Leur m√©moire est automatiquement lib√©r√©e par rust. Le flottant `1.0` est d√©pil√© et le vecteur d√©sallou√© avec un appel √† ``drop()`.

== Trait `Copy`
- Les types primitifs (allou√©s sur la pile) impl√©mentent le trait https://doc.rust-lang.org/core/marker/trait.Copy.html[`Copy`].
- Lors d'une affectation, les donn√©es d'un type avec le trait `Copy` sont copi√©s.
- Chaque variable est l'unique propri√©taire de sa propre copie. L'invariant de ¬´ propri√©t√© unique ¬ª est satisfait.

[source, rust]
----
fn main() {
    let a = [1, 2, 3];
    let mut b = a; // les trois cases du tableau sont copi√©es
    b[1] = 5;
    assert_eq!(a[1], 2); // a n'est pas modifi√©
    assert_eq!(b[1], 5); // seul b est modifi√©
}
----

== Passage par valeur
- De m√™me lors d'un appel de fonction, les types primitifs sont copi√©s.

[source, rust]
----
fn modify(mut tab : [u32; 3]) {
    tab[1] = 4; // c'est la copie locale tab qui est modifi√©e
}

fn main() {
    let mut a = [1, 2, 3]; // (a n'a pas besoin d'√™tre mutable)
    modify(a); //l'argument pass√© par valeur (copie)
    assert_eq!(a[1], 2); // a n'est pas modifi√©
}
----

== Transfert de propri√©taire (affectation)
- Pour les types qui n'impl√©mentent pas le trait `Copy`, une affectation d√©place la propri√©t√© vers une nouvelle variable.

[source, rust]
----
    let v1: Vec<u32> = vec![1, 2, 3]; // v1 est propri√©taire du vecteur
    let v2 = v1; // la propri√©t√© est transf√©r√©e √† v2
    println!("{}", v1[0]); // erreur: ne peut plus √™tre utilis√©
    // erreur: borrow of moved value v1
----

== Tranfert de propri√©taire (appel de fonction) 
- M√™me probl√®me lors d'un appel de fonction, la propri√©t√© est transf√©r√©e.

[source, rust]
----
fn fun(v : Vec<u32>) { ... }

fn main() {
    let v1: Vec<u32> = vec![1, 2, 3]; // v1 est propri√©taire du vecteur
    fun(v1); // la propri√©t√© est transf√©r√©e √† l'argument v 
    println!("{}", v1[0]); // erreur: borrow of moved value v1
}
----

ifdef::backend-revealjs[== !]

=== Erreurs m√©moire √©vit√©es par le transfert
[source, c]
----
#include <stdlib.h>
void fun(char * v) {
  free(v);
}

int main() {
  char * v1 = malloc(3);
  fun(v1);
  free(v1); // <1>
}
// free(): double free detected in tcache 2
// Aborted (core dumped)
----
<1> Erreur en C √† l'ex√©cution. Impossible en Rust, car `v1` n'est plus propri√©taire de la m√©moire.

== Comment appeler une fonction sans perdre la propri√©t√© ?

[source, rust]
----
fn print(v: Vec<u32>) -> Vec<u32> {
    println!("{:?}", v);
    v // on retourne l'objet v pour transf√©rer la propri√©t√© en retour
}

fn main() {
    let v1: Vec<u32> = vec![1, 2, 3]; // v1 est propri√©taire du vecteur
    let v1 = print(v1); // l'appel c√®de puis r√©cup√®re la propri√©t√©.
    assert_eq!(v1[0], 1); // l'acc√®s √† v1[0] est possible 
}
----

WARNING: Le code ci-dessus est correct mais pas idiomatique. C'est fastidieux de devoir passer la propri√©t√© en retour pour de nombreuses variables.

== Emprunts
- Un https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html[emprunt] permet de passer une r√©f√©rence √† un objet sans en c√©der la propri√©t√©.

[source, rust]
----
fn print(v: &Vec<u32>) { // la fonction travaille sur un emprunt elle n'est
    println!("{:?}", v); // pas propri√©taire du vecteur.
}

fn main() {
    let v1: Vec<u32> = vec![1, 2, 3]; // v1 est propri√©taire du vecteur
    print(&v1); // on emprunte une r√©f√©rence sur le vecteur
    assert_eq!(v1[0], 1);
}
----

== Emprunts mutables
- Par d√©faut les emprunts sont immutables. Pour pouvoir modifier l'objet emprunt√©, il nous faut un type `& mut`

[source, rust]
----
fn fun(v: &mut Vec<u32>) {
    v.push(4);
}

fn replace(v: &mut Vec<u32>) {
    *v = vec![4,5]; //<1>
}

fn main() {
    let mut v1: Vec<u32> = vec![1, 2, 3];
    fun(&mut v1); // on emprunte une r√©f√©rence mutable sur le vecteur
    assert_eq!(v1[3], 4);
    replace(&mut v1);
    assert_eq!(v1.len(), 2);
}
----
<1> Pour modifier le contenu, il faut utiliser l'https://doc.rust-lang.org/book/ch15-02-deref.html[op√©rateur `*`] qui permet d'acc√©der √† la valeur r√©f√©renc√©e.

== Emprunts mutables ‚â† Transfert de propri√©t√©
- Un emprunt mutable n'est pas √©quivalent √† un transfert de propri√©t√©
- Par exemple, il n'est pas possible de d√©sallouer une r√©f√©rence mutable üòä

[source, rust]
----
fn fun(v: &mut Vec<u32>) {
    drop(*v); // erreur: cannot move out of *v which is behind a mutable reference 
}
fn main() {
    let mut v1: Vec<u32> = vec![1, 2, 3];
    fun(&mut v1); // on emprunte une r√©f√©rence mutable sur le vecteur
}
----

== Les trois r√®gles des emprunts
. Les emprunts ne peuvent pas avoir une dur√©e de vie plus longue que celle du propri√©taire.

√Ä un point dans le programme, il est possible d'emprunter:
[start=2]
. une ou plusieurs r√©f√©rences `&T`
. exactement une seule r√©f√©rence mutable `&mut T`

ifdef::backend-revealjs[== !]

=== Exemple: erreur √©vit√©e avec la r√®gle (1) 
- Rust nous interdit de retourner une r√©f√©rence sur `x` car il ne peut pas garantir que sa dur√©e de vie est suffisante.

[source, rust]
----
fn fun() -> &u32 { // erreur: missing lifetime specifier
    let x = 1;
    &x
}

fn main() {
    let y : &u32 = fun();  
}
----

- En effet la m√©moire de `x`, sur la pile, est lib√©r√©e en sortie de fonction
- En C, ceci est une source d'erreurs classique !

ifdef::backend-revealjs[== !]

=== Exemple: erreur √©vit√©e avec les r√®gles (2) et (3) 
[source, rust]
----
fn main() {
    let mut v = vec![1, 2, 3, 4];

    rayon::join( // on lance deux threads concurrents
        || {
            v[0] = 5; // premier thread
        },            
        // erreur: cannot borrow `v` as mutable more than once at a time
        || { 
            v[0] = 4; // deuxi√®me thread
        },
    );
}
----

- √âvite les probl√®mes d'acc√®s concurrents. Ici les deux threads voudraient modifier le m√™me tableau. 
- Rust l'interdit car v est emprunt√© deux fois de mani√®re mutable.

== Exercice : un type Stack
* Le but de l'exercice est de d√©finir une structure de pile (_Stack_) en Rust
** pour simplifier, la pile contiendra des entiers (_i32_)
* Une pile peut √™tre d√©finie de mani√®re r√©cursive (comme une liste) de la fa√ßon suivante
** une pile peut √™tre soit la _pile vide_, soit un _√©l√©ment au sommet d'une pile_
** un type disjoint est repr√©sent√© en Rust par un `enum`

ifdef::backend-revealjs[== !]

=== √âtape 1 : premi√®re tentative avec un `enum`
.src/modeles-memoire/exemples/stack_0.rs
[source,rust,indent=0]
----
include::exemples/stack_0.rs[tag=stack]
----
<1> La d√©finition √©tant r√©cursive, Rust ne peut pas d√©terminer la taille du type `Stack`

ifdef::backend-revealjs[== !]

=== √âtape 2 : un `enum` avec de l'allocation dynamique
.src/modeles-memoire/exemples/stack_1.rs
[source,rust,indent=0]
----
include::exemples/stack_1.rs[tag=stack]
----

ifdef::backend-revealjs[== !]

.Tests (src/modeles-memoire/exemples/stack_1.rs)
[source,rust,indent=0]
----
include::exemples/stack_1.rs[tag=stacktst]
----

ifdef::backend-revealjs[== !]

.Op√©rations (src/modeles-memoire/exemples/stack_1.rs)
[source,rust,indent=0]
----
include::exemples/stack_1.rs[tag=stackop]
----

ifdef::backend-revealjs[== !]

=== √âtape 3 : premi√®re tentative avec tous les √©l√©ments sur le tas
.src/modeles-memoire/exemples/stack_2.rs
[source,rust,indent=0]
----
include::exemples/stack_2.rs[tag=stack]
----
<1> `Node` est priv√© et doit le rester

ifdef::backend-revealjs[== !]

=== √âtape 4 : deuxi√®me tentative pour tous les √©l√©ments sur le tas
.src/modeles-memoire/exemples/stack_3.rs
[source,rust,indent=0]
----
include::exemples/stack_3.rs[tag=stack]
----

ifdef::backend-revealjs[== !]

.Tests (src/modeles-memoire/exemples/stack_3.rs)
[source,rust,indent=0]
----
include::exemples/stack_3.rs[tag=stacktst]
----

ifdef::backend-revealjs[== !]

.Op√©rations (src/modeles-memoire/exemples/stack_3.rs)
[source,rust,indent=0]
----
include::exemples/stack_3.rs[tag=stackop]
----
<1> `Link` n'impl√©mente pas le _trait_ `Copy` donc Rust interdit le d√©placement du sommet de la pile

ifdef::backend-revealjs[== !]

=== √âtape 5 : tous les √©l√©ments sur le tas
.Op√©rations (src/modeles-memoire/exemples/stack_4.rs)
[source,rust,indent=0]
----
include::exemples/stack_4.rs[tag=stackop]
----
<1> https://doc.rust-lang.org/std/mem/fn.replace.html[`std::mem::replace`] d√©place le sommet de la pile dans `next` et le remplace par la valeur `Link::Empty`

ifdef::backend-revealjs[== !]

=== √âtape 5 : une petite am√©lioration
.src/modeles-memoire/exemples/stack_4.rs
[source,rust,indent=0]
----
include::exemples/stack_4.rs[tag=stack]
----
<1> Quel type de la biblioth√®que standard pourrait remplacer `Link` ?

ifdef::backend-revealjs[== !]

=== √âtape 6 : en utilisant Option
.src/modeles-memoire/exemples/stack_5.rs
[source,rust,indent=0]
----
include::exemples/stack_5.rs[tag=stack]
----
<1> https://doc.rust-lang.org/std/option/enum.Option.html[`std::option::Option`] remplace avantageusement `Link`

ifdef::backend-revealjs[== !]

.Op√©rations (src/modeles-memoire/exemples/stack_5.rs)
[source,rust,indent=0]
----
include::exemples/stack_5.rs[tag=stackop]
----
<1> https://doc.rust-lang.org/std/mem/fn.take.html[`std::mem::take`] d√©place le sommet de la pile dans `next` et le remplace par la valeur par d√©faut du type `Option` (trait https://doc.rust-lang.org/std/default/trait.Default.html[`std::default::Default`])

ifdef::backend-revealjs[== !]

=== √âtape 7 : ajouter la m√©thode _pop_ (d√©piler)
.Tests (src/modeles-memoire/exemples/stack_6.rs)
[source,rust,indent=0]
----
include::exemples/stack_6.rs[tag=stacktst]
----

ifdef::backend-revealjs[== !]

.Op√©rations (src/modeles-memoire/exemples/stack_6.rs)
[source,rust,indent=0]
----
include::exemples/stack_6.rs[tag=stackop]
----
<1> https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions[`if let`] d√©construit la valeur de type `Option`
<2> le m√™me probl√®me que pour `push` se pose

ifdef::backend-revealjs[== !]

=== √âtape 8 : la m√©thode _pop_ (d√©piler)
.Op√©rations (src/modeles-memoire/exemples/stack_7.rs)
[source,rust,indent=0]
----
include::exemples/stack_7.rs[tag=stackop]
----

== R√©f√©rences

- https://doc.rust-lang.org/1.22.0/book/second-edition/[The Rust book, first and second editions]
- http://cis198-2016s.github.io/[CIS 198 U. Pennsylvania: Rust programming lectures]
- https://stanford-cs242.github.io/f18/lectures/05-1-rust-memory-safety.html[Memory safety in Rust]

[TIP]
====
Exp√©rimentez

* Propri√©t√© ({rustlings}/move_semantics[rustlings], {rbp}/ownership/ownership.html[Rust By Practice], {rbe}/scope/move.html[Rust by Example])
* Emprunt ({rbp}/ownership/borrowing.html[Rust By Practice], {rbe}/scope/borrow.html[Rust by Example])
====
