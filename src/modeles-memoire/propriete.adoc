:imagesdir: figs/
:stem:

= Mod√®le m√©moire Rust: propri√©t√© et emprunts 

== Objectifs

L'innovation majeure de Rust est son mod√®le m√©moire qui combine:

- des v√©rifications statiques qui permettent de d√©tecter les probl√®mes m√©moire
- des abstractions √† co√ªt nul qui permettent de g√©n√©rer un code efficace

Nous allons √©tudier les notions que Rust introduit pour garantir que les programmes sont corrects en m√©moire, en particulier les notions de _Propri√©t√©_ (Ownership) et _Emprunt_ (Borrow).

== Mutabilit√© 

- Par d√©faut les variables sont immutables

[source, rust]
----
    let a = 1;
    let mut b = 1;
    a = 2; // erreur: Cannot assign twice to immutable variable a
    b = 2; // ok
----

== Les variables locales sont allou√©es sur la pile

[source, rust]
----
fn main() {
    let a : u32 = 1;
    let b : f32 = 3.1415;
    let c : [u32; 3] = [1, 2, 3];
    let d = [0; 1 << 30]; // tableau avec 2^30 z√©ros => d√©bordement de pile 
}
----

- Les types primitifs de Rust sont allou√©s sur la pile.

== Allocation sur le tas

- Rust permet aussi d'allouer dynamiquement des objets sur le tas.
- Par exemple, les vecteurs de type +Vec<T>+ sont allou√©s sur le tas.
[source, rust]
----
let v : Vec<u32> = vec![1,2,3]; // <1>
----
<1> Ici +v+ est une variable locale (sur la pile) qui contient un pointeur vers une adresse du tas o√π l'objet +Vec<u32>+ est allou√©.

== Propri√©taire

Pour toute donn√©e, rust d√©finit une variable _propri√©taire_.

IMPORTANT: √Ä tout moment il ne peut y avoir qu'un et un seul propri√©taire. 

[source, rust]
----
fn test() {
    let a = 1.0; //<1>
    let v = vec![1,2,3]; //<2>
    // fin du bloc <3>
}
----
<1> +a+ est propri√©taire du scalaire
<2> +v+ est propri√©taire du vecteur
<3> En fin de bloc +a+ et +v+ sont _hors-port√©e_. Leur m√©moire est automatiquement lib√©r√©e par rust. Le flottant 1.0 est d√©pil√© et le vecteur d√©sallou√© avec un appel √† +.drop()+.

== Trait +Copy+

- Les types primitifs (allou√©s sur la pile) impl√©mentent le trait +Copy+.

- Lors d'une affectation, les donn√©es d'un type avec le trait +Copy+ sont
copi√©s.

- Chaque variable est l'unique propri√©taire de sa propre copie. L'invariant de ¬´ propri√©t√© unique ¬ª est satisfait.

[source, rust]
----
fn main() {
    let a = [1, 2, 3];
    let mut b = a; // les trois cases du tableau sont copi√©es
    b[1] = 5;
    assert_eq!(a[1], 2); // a n'est pas modifi√©
    assert_eq!(b[1], 5); // seul b est modifi√©
}
----

== Passage par valeur

- De m√™me lors d'un appel de fonction, les types primitifs sont copi√©s.

[source, rust]
----
fn modify(mut tab : [u32; 3]) {
    tab[1] = 4; // c'est la copie locale tab qui est modifi√©e
}

fn main() {
    let mut a = [1, 2, 3]; // (a n'a pas besoin d'√™tre mutable)
    modify(a); //l'argument pass√© par valeur (copie)
    assert_eq!(a[1], 2); // a n'est pas modifi√©
}
----

== Transfert de propri√©taire (affectation)

- Pour les types qui n'implementent pas le trait +Copy+, une affectation d√©place la propri√©t√© vers une nouvelle variable.

[source, rust]
----
    let v1: Vec<u32> = vec![1, 2, 3]; // v1 est propri√©taire du vecteur
    let v2 = v1; // la propri√©t√© est transf√©r√©e √† v2
    println!("{}", v1[0]); // erreur: ne peut plus √™tre utilis√©
    // erreur: borrow of moved value v1
----

== Tranfert de propri√©taire (appel de fonction) 

- M√™me probl√®me lors d'un appel de fonction, la propri√©t√© est transf√©r√©e.

[source, rust]
----
fn fun(v : Vec<u32>) { ... }

fn main() {
    let v1: Vec<u32> = vec![1, 2, 3]; // v1 est propri√©taire du vecteur
    fun(v1); // la propri√©t√© est transf√©r√©e √† l'argument v 
    println!("{}", v1[0]); // erreur: borrow of moved value v1
}
----

== Erreurs m√©moire √©vit√©es par le transfert
[source, c]
----
#include <stdlib.h>
void fun(char * v) {
  free(v);
}

int main() {
  char * v1 = malloc(3);
  fun(v1);
  free(v1); // <1>
}
// free(): double free detected in tcache 2
// Aborted (core dumped)
----
<1> Erreur en C √† l'ex√©cution. Impossible en Rust, car +v1+ n'est plus propri√©taire de la m√©moire.  

== Comment appeler une fonction sans perdre la propri√©t√© ?

[source, rust]
----
fn print(v: Vec<u32>) -> Vec<u32> {
    println!("{:?}", v);
    v // on retourne l'objet v pour transf√©rer la propri√©t√© en retour
}

fn main() {
    let v1: Vec<u32> = vec![1, 2, 3]; // v1 est propri√©taire du vecteur
    let v1 = print(v1); // l'appel c√®de puis r√©cup√®re la propri√©t√©.
    assert_eq!(v1[0], 1); // l'acc√®s √† v1[0] est possible 
}
----

WARNING: Le code ci-dessus est correct mais pas idiomatique. C'est fastidieux de devoir passer la propri√©t√© en retour pour de nombreuses variables.

== Emprunts

- Un emprunt permet de passer une r√©f√©rence √† un objet sans en c√©der la propri√©t√©.

[source, rust]
----
fn print(v: &Vec<u32>) { // la fonction travaille sur un emprunt elle n'est
    println!("{:?}", v); // pas propri√©taire du vecteur.
}

fn main() {
    let v1: Vec<u32> = vec![1, 2, 3]; // v1 est propri√©taire du vecteur
    print(&v1); // on emprunte une r√©f√©rence sur le vecteur
    assert_eq!(v1[0], 1);
}
----

== Emprunts mutables

- Par d√©fault les emprunts sont immutables. Pour pouvoir modifier l'objet emprunt√©, il nous faut un type +& mut+

[source, rust]
----
fn fun(v: &mut Vec<u32>) {
    v.push(4);
}

fn replace(v: &mut Vec<u32>) {
    *v = vec![4,5]; // pour modifier le contenu il faut utiliser l'op√©rateur *
}

fn main() {
    let mut v1: Vec<u32> = vec![1, 2, 3];
    fun(&mut v1); // on emprunte une r√©f√©rence mutable sur le vecteur
    assert_eq!(v1[3], 4);
    replace(&mut v1);
    assert_eq!(v1.len(), 2);
}
----

== Emprunts mutables ‚â† Transfert de propri√©t√©

- Un emprunt mutable n'est pas √©quivalent √† un transfert de propri√©t√©
- Par exemple, il n'est pas possible de d√©sallouer une r√©f√©rence mutable üòä

[source, rust]
----
fn fun(v: &mut Vec<u32>) {
    drop(*v); // erreur: cannot move out of *v which is behind a mutable reference 
}
fn main() {
    let mut v1: Vec<u32> = vec![1, 2, 3];
    fun(&mut v1); // on emprunte une r√©f√©rence mutable sur le vecteur
}
----

== Les trois r√®gles des emprunts

. Les emprunts ne peuvent pas avoir une dur√©e de vie plus longue que celle du propri√©taire.

√Ä un point dans le programme, il est possible d'emprunter:

[start=2]
. une ou plusieurs r√©f√©rences +&T+ 
. exactement une seule r√©f√©rence mutable +&mut T+

== Exemple: erreur √©vit√©e avec la r√®gle (1) 

- Rust nous interdit de retourner une r√©f√©rence sur x car il ne peut pas
garantir que sa dur√©e de vie est suffisante.

[source, rust]
----
fn fun() -> &u32 { // erreur: missing lifetime specifier
    let x = 1;
    &x
}

fn main() {
    let y : &u32 = fun();  
}
----

- En effet la m√©moire de x, sur la pile, est lib√©r√©e en sortie de fonction
- En C, ceci est une source d'erreurs classique !

== Exemple: erreur √©vit√©e avec les r√®gles (2) et (3) 

[source, rust]
----
fn main() {
    let mut v = vec![1, 2, 3, 4];

    rayon::join( // on lance deux threads concurrents
        || {
            v[0] = 5; // premier thread
        },            
        // erreur: cannot borrow `v` as mutable more than once at a time
        || { 
            v[0] = 4; // deuxi√®me thread
        },
    );
}
----

- √âvite les probl√®mes d'acc√®s concurrents. Ici les deux threads voudraient modifier le m√™me tableau. 
- Rust l'interdit car v est emprunt√© deux fois de mani√®re mutable.

== R√©f√©rences

- https://doc.rust-lang.org/1.22.0/book/second-edition/[The Rust book, first and second editions]
- http://cis198-2016s.github.io/[CIS 198 U. Pennsylvania: Rust programming lectures]
- https://stanford-cs242.github.io/f18/lectures/05-1-rust-memory-safety.html[Memory safety in Rust]
